import { NextRequest, NextResponse } from 'next/server';
import { searchInfo, searchActivities, searchRestaurants } from '@/lib/serpapi';
import { scrapeContent } from '@/lib/scraper';
import { generateItinerary } from '@/lib/openrouter';
import { prepareContext } from '@/lib/context-preparer';
import { rateLimiter } from '@/lib/rate-limit';

export async function POST(request: NextRequest) {
  try {
    const { preferences, destination, days, budget, travelStyle, currency = 'USD' } = await request.json();

    // Verificar rate limiting
    const rateLimitResult = await rateLimiter.checkRateLimit('itinerary');
    if (!rateLimitResult.allowed) {
      return NextResponse.json(
        {
          error: 'Too Many Requests',
          message: 'Has excedido el límite de generación de itinerarios. Por favor, intenta de nuevo más tarde.',
          retryAfter: rateLimitResult.resetTime
        },
        { status: 429 }
      );
    }

    console.log('Iniciando generación de itinerario para:', destination);

    // 1. Buscar información general sobre el destino
    console.log('Buscando información general sobre', destination);
    const generalInfo = await searchInfo(destination, preferences);
    
    // 2. Buscar actividades y atracciones específicas
    console.log('Buscando actividades y atracciones en', destination);
    const activitiesInfo = await searchActivities(destination, preferences);
    
    // 3. Buscar restaurantes y opciones gastronómicas
    console.log('Buscando restaurantes en', destination);
    const restaurantsInfo = await searchRestaurants(destination, preferences);
    
    // Combinar todos los resultados de búsqueda
    const allSearchResults = [...generalInfo, ...activitiesInfo, ...restaurantsInfo];
    console.log(`Total de resultados de búsqueda: ${allSearchResults.length}`);
    
    // 4. Extraer contenido de las URLs encontradas
    console.log('Extrayendo contenido de', Math.min(allSearchResults.length, 8), 'páginas');
    const scrapedContents = await Promise.all(
      allSearchResults.slice(0, 8).map(async (result, index) => {
        try {
          const content = await scrapeContent(result.link);
          return {
            ...content,
            source: {
              title: result.title,
              url: result.link,
              index: index + 1
            }
          };
        } catch (error) {
          console.error(`Error al scrapear ${result.link}:`, error);
          return null;
        }
      })
    );

    // Filtrar resultados nulos
    const validContents = scrapedContents.filter(content => content !== null);
    console.log(`Contenido válido extraído de ${validContents.length} fuentes`);
    
    // 5. Preparar el contexto con citas a fuentes
    console.log('Preparando contexto con citas a fuentes');
    const preparedContext = prepareContext(validContents, {
      maxLength: 8000, // Limitar para no sobrecargar la IA
      includeCitations: true,
      removeDuplicates: true
    });
    
    console.log(`Contexto preparado: ${preparedContext.wordCount} palabras, ${preparedContext.sources.length} fuentes`);
    
    // 6. Generar itinerario con la información recopilada
    console.log('Generando itinerario con IA');
    const itinerary = await generateItinerary({
      destination,
      days,
      budget,
      travelStyle,
      preferences,
      currency,
      context: preparedContext.text,
      sources: preparedContext.sources
    });

    console.log('Itinerario generado exitosamente');

    return NextResponse.json({
      itinerary: itinerary.text,
      metadata: {
        destination,
        days,
        budget,
        travelStyle,
        sources: preparedContext.sources,
        wordCount: preparedContext.wordCount,
        processingTime: Date.now(),
        searchResultsCount: allSearchResults.length,
        scrapedSourcesCount: validContents.length
      }
    });
  } catch (error) {
    console.error('Error en el orquestador de itinerario:', error);
    return NextResponse.json(
      { error: 'Error al generar el itinerario', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}

// Endpoint para generación de itinerario con actualizaciones en tiempo real (SSE)
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const destination = searchParams.get('destination');
  const days = searchParams.get('days');
  const budget = searchParams.get('budget');
  const travelStyle = searchParams.get('travelStyle');
  const preferences = searchParams.get('preferences')?.split(',') || [];

  if (!destination || !days || !budget || !travelStyle) {
    return new Response('Parámetros requeridos: destination, days, budget, travelStyle', { status: 400 });
  }

  // Aquí implementaríamos la lógica para SSE
  // Por ahora, devolvemos un error indicando que esta funcionalidad está en desarrollo
  return new Response('Esta funcionalidad está en desarrollo', { status: 501 });
}